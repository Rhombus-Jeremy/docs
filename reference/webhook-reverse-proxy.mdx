---
title: Webhook Listeners on Private Servers
description: Learn how to use reverse SSH tunneling to expose webhook listeners running on private servers without requiring a public IP or VPN
---

import { Callout } from 'fumadocs-ui/components/callout';
import { Steps, Step } from 'fumadocs-ui/components/steps';
import { Tabs, Tab } from 'fumadocs-ui/components/tabs';

# Webhook Listeners on Private Servers

<Callout type="info" title="Problem Solved">
This guide shows you how to receive **Rhombus webhooks** on servers behind firewalls or NAT without requiring a public IP address or complex VPN setup.
</Callout>

When working with webhook integrations, it's common to require a publicly accessible endpoint. However, some environments‚Äîparticularly on-premises or secured networks‚Äîdo not allow direct public IP exposure. This guide walks through how to use **reverse SSH tunneling** to expose a webhook listener running on a private server.

## üéØ Use Cases

This method is ideal when:

<div className="grid grid-cols-1 md:grid-cols-2 gap-4 my-6">
  <div className="p-4 border border-blue-200 rounded-lg bg-blue-50">
    <div className="flex items-center gap-2 mb-2">
      <span className="text-blue-600">üîí</span>
      <strong className="text-blue-900">Security Requirements</strong>
    </div>
    <p className="text-blue-800 text-sm">Your server is behind a NAT/firewall and cannot have a public IP</p>
  </div>
  
  <div className="p-4 border border-green-200 rounded-lg bg-green-50">
    <div className="flex items-center gap-2 mb-2">
      <span className="text-green-600">üì°</span>
      <strong className="text-green-900">Webhook Integration</strong>
    </div>
    <p className="text-green-800 text-sm">You need to receive webhook POST requests from Rhombus</p>
  </div>
  
  <div className="p-4 border border-purple-200 rounded-lg bg-purple-50">
    <div className="flex items-center gap-2 mb-2">
      <span className="text-purple-600">üõ°Ô∏è</span>
      <strong className="text-purple-900">Secure & Simple</strong>
    </div>
    <p className="text-purple-800 text-sm">You want a secure way to forward traffic to your local webhook listener</p>
  </div>
  
  <div className="p-4 border border-orange-200 rounded-lg bg-orange-50">
    <div className="flex items-center gap-2 mb-2">
      <span className="text-orange-600">üè¢</span>
      <strong className="text-orange-900">Enterprise Networks</strong>
    </div>
    <p className="text-orange-800 text-sm">Corporate firewalls prevent direct inbound connections</p>
  </div>
</div>

## üèóÔ∏è Architecture Overview

<Callout type="info" title="How It Works">
The reverse SSH tunnel connects the public relay back to your local server, forwarding external traffic securely to your webhook listener.
</Callout>

<div className="overflow-x-auto my-6">
  <table className="min-w-full border border-gray-200 rounded-lg">
    <thead className="bg-gray-50">
      <tr>
        <th className="px-6 py-3 text-left text-sm font-medium text-gray-900 border-b">Component</th>
        <th className="px-6 py-3 text-left text-sm font-medium text-gray-900 border-b">Role</th>
        <th className="px-6 py-3 text-left text-sm font-medium text-gray-900 border-b">Examples</th>
      </tr>
    </thead>
    <tbody>
      <tr className="border-b">
        <td className="px-6 py-4 text-sm font-medium text-blue-600">Private Server</td>
        <td className="px-6 py-4 text-sm text-gray-700">Runs the webhook listener</td>
        <td className="px-6 py-4 text-sm font-mono text-gray-600">localhost:8080</td>
      </tr>
      <tr className="border-b">
        <td className="px-6 py-4 text-sm font-medium text-green-600">Public Relay</td>
        <td className="px-6 py-4 text-sm text-gray-700">Small public cloud instance</td>
        <td className="px-6 py-4 text-sm font-mono text-gray-600">EC2, Linode, DigitalOcean</td>
      </tr>
      <tr>
        <td className="px-6 py-4 text-sm font-medium text-purple-600">Webhook Sender</td>
        <td className="px-6 py-4 text-sm text-gray-700">Sends HTTP POST requests</td>
        <td className="px-6 py-4 text-sm font-mono text-gray-600">Rhombus Cloud Services</td>
      </tr>
    </tbody>
  </table>
</div>

## üöÄ Step-by-Step Implementation

<Steps>
<Step>
### Provision a Public Relay Server

Set up a lightweight Linux server (e.g., Ubuntu) on a cloud provider like AWS, GCP, or DigitalOcean.

**Requirements:**
- Assign a public IP or domain name (e.g., `relay.yourdomain.com`)
- Open inbound ports (**80** or **443**) for HTTP/HTTPS traffic
- Minimal specs: 1 CPU, 512MB RAM is sufficient

<Tabs items={['AWS EC2', 'DigitalOcean', 'Google Cloud']}>
<Tab value="AWS EC2">
```bash
# Example AWS EC2 instance setup
aws ec2 run-instances \
  --image-id ami-0abcdef1234567890 \
  --count 1 \
  --instance-type t2.micro \
  --key-name my-key-pair \
  --security-groups my-security-group
```
</Tab>
<Tab value="DigitalOcean">
```bash
# Example DigitalOcean droplet setup
doctl compute droplet create relay-server \
  --size s-1vcpu-512mb-10gb \
  --image ubuntu-20-04-x64 \
  --region nyc3
```
</Tab>
<Tab value="Google Cloud">
```bash
# Example Google Cloud VM setup
gcloud compute instances create relay-server \
  --zone=us-central1-a \
  --machine-type=e2-micro \
  --image-family=ubuntu-2004-lts \
  --image-project=ubuntu-os-cloud
```
</Tab>
</Tabs>

</Step>

<Step>
### Configure SSH for Remote Tunneling

On the **relay server**, modify the SSH daemon configuration to allow remote port forwarding:

```bash
sudo nano /etc/ssh/sshd_config
```

Ensure the following options are set:

```bash
# Enable gateway ports for remote forwarding
GatewayPorts yes

# Allow TCP forwarding
AllowTcpForwarding yes

# Allow opening any port
PermitOpen any
```

<Callout type="warn" title="Security Note">
These settings allow remote port forwarding. Only enable on dedicated relay servers and secure with proper firewall rules.
</Callout>

Restart the SSH service:

```bash
sudo systemctl restart ssh
# Verify SSH is running
sudo systemctl status ssh
```

</Step>

<Step>
### Set Up SSH Key Authentication

On your **private server** (where the webhook listener runs), generate SSH keys and copy them to the relay:

```bash
# Generate SSH key pair
ssh-keygen -t rsa -b 4096 -C "webhook-tunnel@yourdomain.com"

# Copy public key to relay server
ssh-copy-id -i ~/.ssh/id_rsa.pub user@<RELAY_PUBLIC_IP>
```

Verify passwordless SSH access:

```bash
# Test connection (should not prompt for password)
ssh user@<RELAY_PUBLIC_IP>
```

<Callout type="info" title="Pro Tip">
Use a dedicated SSH key for the tunnel to make key rotation easier and improve security isolation.
</Callout>

</Step>

<Step>
### Establish the Reverse SSH Tunnel

Run the following command on your **private server**:

<Tabs items={['Basic Tunnel', 'Background Process', 'Persistent Tunnel']}>
<Tab value="Basic Tunnel">
```bash
# Basic reverse SSH tunnel
ssh -R 80:localhost:8080 user@<RELAY_PUBLIC_IP>
```

**Explanation:**
- `80` - External port exposed by the relay server
- `localhost:8080` - Your local webhook listener address
- Connection stays active in foreground
</Tab>
<Tab value="Background Process">
```bash
# Run tunnel in background
ssh -Nf -R 80:localhost:8080 user@<RELAY_PUBLIC_IP>
```

**Options:**
- `-N` - Don't execute remote commands
- `-f` - Go to background after authentication
- `-R` - Remote port forwarding
</Tab>
<Tab value="Persistent Tunnel">
```bash
# Install autossh for persistent tunneling
sudo apt install autossh

# Run persistent tunnel
autossh -M 0 -Nf -R 80:localhost:8080 user@<RELAY_PUBLIC_IP>
```

**Benefits:**
- Auto-reconnects if connection drops
- Built-in monitoring and recovery
- Ideal for production environments
</Tab>
</Tabs>

</Step>

<Step>
### Test the Setup

Now test that your tunnel is working correctly:

```bash
# 1. Start your webhook listener locally
# Example: Node.js server on port 8080
node webhook-server.js

# 2. Test from external source
curl -X POST http://<RELAY_PUBLIC_IP>/webhook \
  -H "Content-Type: application/json" \
  -d '{"test": "webhook payload"}'

# 3. Check your local server logs for the request
```

**Webhook URL for Rhombus:**
```
http://<RELAY_PUBLIC_IP>/your-webhook-endpoint
```

<Callout type="success" title="Success Indicator">
If you see the request in your local webhook listener logs, the tunnel is working correctly!
</Callout>

</Step>
</Steps>

## üîí Security Enhancements

### HTTPS with NGINX

For production environments, add HTTPS support:

<Tabs items={['NGINX Setup', 'SSL Certificate', 'Configuration']}>
<Tab value="NGINX Setup">
```bash
# Install NGINX on relay server
sudo apt update
sudo apt install nginx

# Create basic configuration
sudo nano /etc/nginx/sites-available/webhook-tunnel
```
</Tab>
<Tab value="SSL Certificate">
```bash
# Install Certbot for Let's Encrypt
sudo apt install certbot python3-certbot-nginx

# Generate SSL certificate
sudo certbot --nginx -d your-domain.com
```
</Tab>
<Tab value="Configuration">
```nginx
server {
    listen 443 ssl;
    server_name your-domain.com;
    
    ssl_certificate /etc/letsencrypt/live/your-domain.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/your-domain.com/privkey.pem;
    
    location / {
        proxy_pass http://localhost:80;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
```
</Tab>
</Tabs>

### Security Best Practices

<div className="grid grid-cols-1 md:grid-cols-2 gap-4 my-6">
  <div className="p-4 border border-red-200 rounded-lg bg-red-50">
    <div className="flex items-center gap-2 mb-3">
      <span className="text-red-600">üîë</span>
      <strong className="text-red-900">Authentication</strong>
    </div>
    <ul className="text-red-800 text-sm space-y-1">
      <li>‚Ä¢ Use key-based SSH authentication only</li>
      <li>‚Ä¢ Disable password authentication</li>
      <li>‚Ä¢ Rotate SSH keys regularly</li>
    </ul>
  </div>
  
  <div className="p-4 border border-yellow-200 rounded-lg bg-yellow-50">
    <div className="flex items-center gap-2 mb-3">
      <span className="text-yellow-600">üõ°Ô∏è</span>
      <strong className="text-yellow-900">Network Security</strong>
    </div>
    <ul className="text-yellow-800 text-sm space-y-1">
      <li>‚Ä¢ Restrict traffic with firewall rules</li>
      <li>‚Ä¢ Use fail2ban for SSH protection</li>
      <li>‚Ä¢ Monitor tunnel connections</li>
    </ul>
  </div>
</div>

```bash
# Example firewall rules (UFW)
sudo ufw allow ssh
sudo ufw allow 80/tcp
sudo ufw allow 443/tcp
sudo ufw --force enable

# Disable password authentication
sudo sed -i 's/#PasswordAuthentication yes/PasswordAuthentication no/' /etc/ssh/sshd_config
sudo systemctl restart ssh
```

## üöÄ Production Deployment

### Systemd Service for Auto-Start

Create a systemd service to automatically start the tunnel on boot:

```bash
# Create service file
sudo nano /etc/systemd/system/webhook-tunnel.service
```

```ini
[Unit]
Description=Webhook SSH Tunnel
After=network.target

[Service]
Type=simple
User=your-username
ExecStart=/usr/bin/autossh -M 0 -N -R 80:localhost:8080 user@relay-server.com
Restart=always
RestartSec=5
Environment="AUTOSSH_GATETIME=0"
Environment="AUTOSSH_POLL=30"

[Install]
WantedBy=multi-user.target
```

```bash
# Enable and start the service
sudo systemctl daemon-reload
sudo systemctl enable webhook-tunnel
sudo systemctl start webhook-tunnel

# Check status
sudo systemctl status webhook-tunnel
```

### Monitoring and Logging

```bash
# Monitor tunnel status
ps aux | grep autossh

# Check tunnel logs
journalctl -u webhook-tunnel -f

# Test tunnel health
curl -s http://<RELAY_PUBLIC_IP>/health || echo "Tunnel down"
```

## ‚úÖ Benefits of This Approach

<div className="grid grid-cols-1 md:grid-cols-2 gap-6 my-8">
  <div className="space-y-4">
    <div className="flex items-start gap-3">
      <div className="w-6 h-6 bg-green-100 rounded-full flex items-center justify-center flex-shrink-0 mt-0.5">
        <span className="text-green-600 text-sm">‚úÖ</span>
      </div>
      <div>
        <strong className="text-gray-900">Works Behind Firewalls</strong>
        <p className="text-gray-600 text-sm mt-1">Functions perfectly behind NAT or corporate firewalls</p>
      </div>
    </div>
    
    <div className="flex items-start gap-3">
      <div className="w-6 h-6 bg-green-100 rounded-full flex items-center justify-center flex-shrink-0 mt-0.5">
        <span className="text-green-600 text-sm">‚úÖ</span>
      </div>
      <div>
        <strong className="text-gray-900">No VPN Required</strong>
        <p className="text-gray-600 text-sm mt-1">Eliminates complex VPN setup and maintenance</p>
      </div>
    </div>
  </div>
  
  <div className="space-y-4">
    <div className="flex items-start gap-3">
      <div className="w-6 h-6 bg-green-100 rounded-full flex items-center justify-center flex-shrink-0 mt-0.5">
        <span className="text-green-600 text-sm">‚úÖ</span>
      </div>
      <div>
        <strong className="text-gray-900">Easy Automation</strong>
        <p className="text-gray-600 text-sm mt-1">Simple to automate with autossh and systemd</p>
      </div>
    </div>
    
    <div className="flex items-start gap-3">
      <div className="w-6 h-6 bg-green-100 rounded-full flex items-center justify-center flex-shrink-0 mt-0.5">
        <span className="text-green-600 text-sm">‚úÖ</span>
      </div>
      <div>
        <strong className="text-gray-900">Enterprise Safe</strong>
        <p className="text-gray-600 text-sm mt-1">Fully outbound connection‚Äîsafe for most enterprise networks</p>
      </div>
    </div>
  </div>
</div>

## üîß Troubleshooting

<Callout type="warn" title="Common Issues">
Here are solutions to the most common problems when setting up reverse SSH tunnels.
</Callout>

### Connection Issues

<Tabs items={['SSH Connection Fails', 'Tunnel Not Working', 'Port Already in Use']}>
<Tab value="SSH Connection Fails">
**Problem:** Cannot establish SSH connection to relay server

**Solutions:**
```bash
# Check SSH service status
sudo systemctl status ssh

# Verify firewall allows SSH
sudo ufw status

# Test with verbose logging
ssh -v user@<RELAY_PUBLIC_IP>

# Check SSH configuration
sudo sshd -t
```
</Tab>
<Tab value="Tunnel Not Working">
**Problem:** Tunnel established but webhook requests don't reach local server

**Solutions:**
```bash
# Check if port is bound on relay
ss -tlnp | grep :80

# Test local webhook server
curl localhost:8080/test

# Verify GatewayPorts setting
sudo grep GatewayPorts /etc/ssh/sshd_config

# Check relay server logs
sudo journalctl -u ssh -f
```
</Tab>
<Tab value="Port Already in Use">
**Problem:** Port 80 already in use on relay server

**Solutions:**
```bash
# Find what's using port 80
sudo lsof -i :80

# Use alternative port
ssh -R 8080:localhost:8080 user@<RELAY_PUBLIC_IP>

# Stop conflicting service (e.g., Apache)
sudo systemctl stop apache2
```
</Tab>
</Tabs>

## üìö Example Implementation

Here's a complete example of a webhook listener and tunnel setup:

<Tabs items={['Node.js Webhook', 'Python Webhook', 'C# Webhook']}>
<Tab value="Node.js Webhook">
```javascript
// webhook-server.js
const express = require('express');
const app = express();

app.use(express.json());

app.post('/rhombus-webhook', (req, res) => {
  console.log('Received webhook:', req.body);
  
  // Process webhook payload
  const { eventType, deviceId, timestamp } = req.body;
  
  // Your business logic here
  console.log(`Event: ${eventType} from device ${deviceId} at ${timestamp}`);
  
  res.status(200).json({ status: 'received' });
});

app.get('/health', (req, res) => {
  res.status(200).json({ status: 'healthy' });
});

const PORT = 8080;
app.listen(PORT, () => {
  console.log(`Webhook server running on port ${PORT}`);
});
```
</Tab>
<Tab value="Python Webhook">
```python
# webhook_server.py
from flask import Flask, request, jsonify
import logging

app = Flask(__name__)
logging.basicConfig(level=logging.INFO)

@app.route('/rhombus-webhook', methods=['POST'])
def webhook():
    data = request.get_json()
    app.logger.info(f'Received webhook: {data}')
    
    # Process webhook payload
    event_type = data.get('eventType')
    device_id = data.get('deviceId')
    timestamp = data.get('timestamp')
    
    # Your business logic here
    app.logger.info(f'Event: {event_type} from device {device_id} at {timestamp}')
    
    return jsonify({'status': 'received'}), 200

@app.route('/health', methods=['GET'])
def health():
    return jsonify({'status': 'healthy'}), 200

if __name__ == '__main__':
    app.run(host='localhost', port=8080, debug=True)
```
</Tab>
<Tab value="C# Webhook">
```csharp
// WebhookListener.cs
using Microsoft.AspNetCore.Mvc;

[ApiController]
[Route("/")]
public class WebhookController : ControllerBase
{
    private readonly ILogger<WebhookController> _logger;

    public WebhookController(ILogger<WebhookController> logger)
    {
        _logger = logger;
    }

    [HttpPost("rhombus-webhook")]
    public IActionResult ReceiveWebhook([FromBody] dynamic payload)
    {
        _logger.LogInformation($"Received webhook: {payload}");
        
        // Process webhook payload
        string eventType = payload.eventType;
        string deviceId = payload.deviceId;
        string timestamp = payload.timestamp;
        
        // Your business logic here
        _logger.LogInformation($"Event: {eventType} from device {deviceId} at {timestamp}");
        
        return Ok(new { status = "received" });
    }

    [HttpGet("health")]
    public IActionResult Health()
    {
        return Ok(new { status = "healthy" });
    }
}
```
</Tab>
</Tabs>

## üéØ Next Steps

<Cards>
  <Card 
    title="üîê Authentication Setup" 
    description="Learn how to authenticate with Rhombus API for webhook registration"
    href="/quickstart" 
  />
  <Card 
    title="üì° Webhook Configuration" 
    description="Configure webhooks in the Rhombus Console"
    href="https://console.rhombussystems.com"
    external
  />
  <Card 
    title="üí¨ Get Help" 
    description="Join our community for webhook integration support"
    href="https://rhombus.community"
    external
  />
</Cards>

---

<Callout type="success" title="Success!">
You now have a secure, reliable way to receive Rhombus webhooks on your private infrastructure without exposing your servers to the internet or requiring complex VPN setups.
</Callout>