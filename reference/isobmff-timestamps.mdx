---
title: ISOBMFF Millisecond Timestamps
description: Learn how to leverage Rhombus' custom millisecond timestamps embedded in ISOBMFF containers for precise video synchronization
---

import { Callout } from 'fumadocs-ui/components/callout';
import { CodeBlock } from 'fumadocs-ui/components/codeblock';
import { Step, Steps } from 'fumadocs-ui/components/steps';
import { Tab, Tabs } from 'fumadocs-ui/components/tabs';

# Leveraging Rhombus' Millisecond Timestamps in ISOBMFF for Precise Video Synchronization

When dealing with video segments—especially in systems that rely on distributed cameras, cloud storage, and multiple data streams—**time synchronization** becomes one of the most critical challenges. Without precise timing information, aligning events between multiple feeds (e.g., video, audio, and sensor data) becomes error-prone.

Rhombus has implemented a **custom timestamp embedding** strategy that provides millisecond precision within `.mp4`/`.m4v` video segments, going beyond the coarse timing fields traditionally found in standard ISOBMFF (ISO Base Media File Format) containers.

<Callout type="info">
This article explains what this approach means, why it's important, and how developers can retrieve and use this timestamp for building time-aligned applications.
</Callout>

## Understanding ISOBMFF and the "free" Atom

The **ISOBMFF** standard (ISO/IEC 14496-12) is the container format underlying `.mp4`, `.m4v`, `.mov`, and many streaming segment formats like `.fMP4`. Its structure is based on **boxes (atoms)**—self-contained data units identified by a 4-character code (e.g., `moov`, `mdat`, `free`).

<Callout type="warn">
**Standard timestamps** in ISOBMFF (e.g., `creation_time` in the `mvhd` box) typically have **seconds-level resolution**. This is fine for some media workflows, but insufficient for **multi-camera synchronization** or **high-speed event correlation**.
</Callout>

Rhombus solves this by **embedding a millisecond-precision timestamp** inside a `free` atom. This is a non-standard, yet fully ISOBMFF-compliant, method.

## The Rhombus Custom Timestamp

When Rhombus segments video (and if pulling actual segments, not a live transport stream), a **custom metadata signature** is written into the `free` box:

<Steps>
<Step>
**Box Type:** `free`
- In ISOBMFF, `free` is normally a placeholder box containing unused space.
- Rhombus repurposes this to carry timestamp metadata.
</Step>

<Step>
**Signature:**
- The first 4 bytes are the ASCII string `rhom`—identifying it as **Rhombus-specific data**.
</Step>

<Step>
**Millisecond Timestamp:**
- The next **8 bytes** are a **64-bit integer** representing the start time of the video content, measured in **milliseconds since the Unix epoch** (UTC).
</Step>
</Steps>

**Binary layout example:**
```
[ free box length ][ 'free' ][ 'rhom' ][ 8-byte timestamp (ms since epoch) ]
```

## Why This Is Important for Developers

This design choice unlocks **precise synchronization** capabilities:

- **Multi-camera alignment:** Align video feeds from different cameras to within 1 ms.
- **Sensor fusion:** Merge video with IoT sensor data (e.g., access control events, environmental readings).
- **Forensic accuracy:** Reconstruct events down to sub-second intervals in investigations.
- **Reduced drift:** Avoid errors that accumulate when relying solely on client system clocks or NTP sync.

<Callout type="tip">
For ecosystem and integration partners, this makes Rhombus video streams **highly interoperable** with third-party analytics, AI/ML pipelines, and real-time monitoring systems.
</Callout>

## Retrieving the Timestamp

### 1. Parsing the ISOBMFF File

You can use open-source libraries to read the `free` box from an `.mp4`/`.m4v` segment and check for the `rhom` signature.

**Example libraries:**
- **ISOBMFF Parser (C++/Swift):** [https://github.com/DigiDNA/ISOBMFF](https://github.com/DigiDNA/ISOBMFF)
- **JavaScript MP4 Parser:** [https://gpac.github.io/mp4box.js/test/filereader.html](https://gpac.github.io/mp4box.js/test/filereader.html) (interactive online viewer)

### 2. Implementation Examples

<Tabs items={['Python', 'JavaScript', 'C++']}>
<Tab value="Python">
```python
import struct
import datetime

def extract_rhombus_timestamp(file_path):
    with open(file_path, "rb") as f:
        data = f.read()
    
    # Find the 'free' box
    idx = data.find(b'free')
    if idx == -1:
        return None
    
    # Search for 'rhom' after 'free'
    rhom_idx = data.find(b'rhom', idx)
    if rhom_idx == -1:
        return None
    
    # Read the next 8 bytes after 'rhom'
    timestamp_bytes = data[rhom_idx + 4 : rhom_idx + 12]
    timestamp_ms = int.from_bytes(timestamp_bytes, byteorder="big")
    
    # Convert to human-readable UTC time
    timestamp_dt = datetime.datetime.utcfromtimestamp(timestamp_ms / 1000.0)
    return timestamp_ms, timestamp_dt

# Example usage:
timestamp_ms, timestamp_dt = extract_rhombus_timestamp("video_segment.mp4")
print(f"Timestamp (ms since epoch): {timestamp_ms}")
print(f"UTC Time: {timestamp_dt}")

# Sample output:
# Timestamp (ms since epoch): 1722945678123
# UTC Time: 2024-08-06 15:21:18.123000
```
</Tab>
<Tab value="JavaScript">
```javascript
function extractRhombusTimestamp(arrayBuffer) {
    const data = new Uint8Array(arrayBuffer);
    
    // Find 'free' box
    const freePattern = new Uint8Array([0x66, 0x72, 0x65, 0x65]); // 'free'
    let freeIndex = -1;
    
    for (let i = 0; i <= data.length - 4; i++) {
        if (data.subarray(i, i + 4).every((val, idx) => val === freePattern[idx])) {
            freeIndex = i;
            break;
        }
    }
    
    if (freeIndex === -1) return null;
    
    // Find 'rhom' signature
    const rhomPattern = new Uint8Array([0x72, 0x68, 0x6f, 0x6d]); // 'rhom'
    let rhomIndex = -1;
    
    for (let i = freeIndex; i <= data.length - 4; i++) {
        if (data.subarray(i, i + 4).every((val, idx) => val === rhomPattern[idx])) {
            rhomIndex = i;
            break;
        }
    }
    
    if (rhomIndex === -1) return null;
    
    // Extract 8-byte timestamp (big-endian)
    const timestampBytes = data.subarray(rhomIndex + 4, rhomIndex + 12);
    let timestamp = 0;
    for (let i = 0; i < 8; i++) {
        timestamp = timestamp * 256 + timestampBytes[i];
    }
    
    return {
        timestampMs: timestamp,
        utcTime: new Date(timestamp)
    };
}
```
</Tab>
<Tab value="C++">
```cpp
#include <fstream>
#include <vector>
#include <cstdint>
#include <chrono>

struct RhombusTimestamp {
    uint64_t timestampMs;
    std::chrono::system_clock::time_point utcTime;
};

std::optional<RhombusTimestamp> extractRhombusTimestamp(const std::string& filePath) {
    std::ifstream file(filePath, std::ios::binary);
    if (!file) return std::nullopt;
    
    std::vector<uint8_t> data((std::istreambuf_iterator<char>(file)),
                              std::istreambuf_iterator<char>());
    
    // Find 'free' box
    const std::vector<uint8_t> freePattern = {0x66, 0x72, 0x65, 0x65};
    auto freeIt = std::search(data.begin(), data.end(), 
                              freePattern.begin(), freePattern.end());
    if (freeIt == data.end()) return std::nullopt;
    
    // Find 'rhom' signature
    const std::vector<uint8_t> rhomPattern = {0x72, 0x68, 0x6f, 0x6d};
    auto rhomIt = std::search(freeIt, data.end(), 
                              rhomPattern.begin(), rhomPattern.end());
    if (rhomIt == data.end()) return std::nullopt;
    
    // Extract 8-byte timestamp (big-endian)
    uint64_t timestamp = 0;
    for (int i = 0; i < 8; i++) {
        timestamp = (timestamp << 8) | *(rhomIt + 4 + i);
    }
    
    auto utcTime = std::chrono::system_clock::from_time_t(timestamp / 1000);
    utcTime += std::chrono::milliseconds(timestamp % 1000);
    
    return RhombusTimestamp{timestamp, utcTime};
}
```
</Tab>
</Tabs>

## Best Practices for Integration

<Steps>
<Step>
**Validate the signature:** Always confirm the `rhom` tag before interpreting the following bytes as a timestamp.
</Step>

<Step>
**Account for time zones:** The timestamp is UTC-based; convert it if your application needs local time.
</Step>

<Step>
**Use as a reference clock:** Combine with local frame timestamps for frame-accurate alignment.
</Step>

<Step>
**Version for future-proofing:** Store your parsing logic in a modular way in case Rhombus adds new metadata formats.
</Step>
</Steps>

## Conclusion

Rhombus' method of embedding a **millisecond-precision UTC timestamp in the `free` atom** of ISOBMFF segments provides developers with a powerful tool for **precise event alignment** in multi-stream environments.

This approach preserves compatibility with existing video tooling while unlocking **sub-second accuracy** for analytics, AI, and real-time monitoring—critical for advanced integrations in the Rhombus ecosystem.

<Callout type="tip">
**Next Steps for Developers:**
- Experiment with the [ISOBMFF GitHub library](https://github.com/DigiDNA/ISOBMFF) to parse Rhombus segments.
- Use the [MP4Box.js online viewer](https://gpac.github.io/mp4box.js/test/filereader.html) to visually inspect the box structure.
- Incorporate timestamp extraction into your ingest pipeline for perfectly synchronized multi-source datasets.
</Callout>
